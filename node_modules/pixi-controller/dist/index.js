"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BUTTON: () => BUTTON,
  Keyboard: () => Keyboard,
  PIXIController: () => PIXIController,
  PLAYER: () => PLAYER
});
module.exports = __toCommonJS(src_exports);

// src/mouse.ts
var import_nom_events = __toESM(require("nom-events"));
var Mouse = class {
  constructor(canvas) {
    this.posLocalY = 0;
    this.posLocalX = 0;
    this.posGlobalX = 0;
    this.posGlobalY = 0;
    this._prevent = {
      value: false,
      code: []
    };
    this.mouseMoveListener = (event) => {
      const buttonCode = event.button;
      this.preventMiddle(buttonCode, event);
      if (this.posLocalX != event.clientX || this.posLocalY != event.clientY) {
        this.events.call("move", event.clientX, this.posLocalY);
        this.events.call("moveLocal", event.clientX, this.posLocalY);
        this.posLocalX = event.clientX;
        this.posLocalY = event.clientY;
      }
      if (this.posGlobalX != event.screenX || this.posGlobalY != event.screenY) {
        this.events.call("moveGlobal", event.screenX, event.screenY);
        this.posGlobalX = event.screenX;
        this.posGlobalY = event.screenY;
      }
    };
    this.mouseDownListener = (event) => {
      const buttonCode = event.button;
      this.preventMiddle(buttonCode, event);
      if (!this.buttonStates.get(buttonCode)) {
        event.posLocalX = this.getPosLocalX();
        event.posLocalY = this.getPosLocalY();
        this.buttonStates.set(buttonCode, event);
        this.events.call("pressed", buttonCode, event, this.getPosLocalX(), this.getPosLocalY());
        this.events.call("pressed_" + buttonCode, buttonCode, event, this.getPosLocalX(), this.getPosLocalY());
      }
    };
    this.mouseUpListener = (event) => {
      const buttonCode = event.button;
      this.preventMiddle(buttonCode, event);
      event = this.buttonStates.get(buttonCode);
      if (event) {
        event.wasReleased = true;
        this.events.call(
          "released",
          buttonCode,
          event,
          this.getPosLocalX(),
          this.getPosLocalY(),
          event.posLocalX,
          event.posLocalY,
          this.getPosLocalX() - event.posLocalX,
          this.getPosLocalY() - event.posLocalY
        );
        this.events.call(
          "released_" + buttonCode,
          buttonCode,
          event,
          this.getPosLocalX(),
          this.getPosLocalY(),
          event.posLocalX,
          event.posLocalY,
          this.getPosLocalX() - event.posLocalX,
          this.getPosLocalY() - event.posLocalY
        );
      }
    };
    this.mouseMenuContext = (event) => {
      this.preventMiddle(event.button, event);
    };
    this.buttonStates = /* @__PURE__ */ new Map();
    this.events = new import_nom_events.default();
    this.canvasElement = canvas;
    if (!this.canvasElement)
      throw new Error("pixi-controller: error for search <canvas /> tag.");
    this.canvasElement.addEventListener("mousemove", this.mouseMoveListener);
    this.canvasElement.addEventListener("mousedown", this.mouseDownListener);
    this.canvasElement.addEventListener("mouseup", this.mouseUpListener);
    this.canvasElement.addEventListener("contextmenu", this.mouseMenuContext);
  }
  getMousePos(event) {
    const rect = this.canvasElement.getBoundingClientRect();
    return {
      x: event.clientX - rect.left,
      y: event.clientY - rect.top
    };
  }
  getPosGlobalX() {
    return this.posGlobalX;
  }
  getPosGlobalY() {
    return this.posGlobalY;
  }
  getPosLocalX() {
    return this.posLocalX;
  }
  getPosLocalY() {
    return this.posLocalY;
  }
  getPosX() {
    return this.getPosLocalX();
  }
  getPosY() {
    return this.getPosLocalY();
  }
  clear() {
    this.buttonStates.clear();
  }
  reset(_canvas) {
    _canvas ? this.canvasElement = _canvas : this.canvasElement = document.getElementsByTagName("canvas")[0];
    this.clear();
    this.events = new import_nom_events.default();
    this.canvasElement.removeEventListener("mousemove", this.mouseMoveListener);
    this.canvasElement.removeEventListener("mousedown", this.mouseDownListener);
    this.canvasElement.removeEventListener("mouseup", this.mouseUpListener);
    this.canvasElement.removeEventListener("contextmenu", this.mouseMenuContext);
    this.canvasElement.addEventListener("mousemove", this.mouseMoveListener);
    this.canvasElement.addEventListener("mousedown", this.mouseDownListener);
    this.canvasElement.addEventListener("mouseup", this.mouseUpListener);
    this.canvasElement.addEventListener("contextmenu", this.mouseMenuContext);
  }
  update() {
    this.buttonStates.forEach((value, buttonCode) => {
      const event = this.buttonStates.get(buttonCode);
      event.alreadyPressed = true;
      if (event.wasReleased)
        this.buttonStates.delete(buttonCode);
      this.events.call(
        "down",
        buttonCode,
        event,
        this.getPosLocalX(),
        this.getPosLocalY(),
        event.posLocalX,
        event.posLocalY,
        this.getPosLocalX() - event.posLocalX,
        this.getPosLocalY() - event.posLocalY
      );
      this.events.call(
        "down_" + buttonCode,
        buttonCode,
        event,
        this.getPosLocalX(),
        this.getPosLocalY(),
        event.posLocalX,
        event.posLocalY,
        this.getPosLocalX() - event.posLocalX,
        this.getPosLocalY() - event.posLocalY
      );
    });
  }
  isButtonDown(...args) {
    let result = false;
    for (const buttonCode of args) {
      const key = this.buttonStates.get(buttonCode);
      if (key && !key.wasReleased)
        result = true;
    }
    return result;
  }
  isButtonUp(...args) {
    return !this.isButtonDown(args);
  }
  isButtonPressed(...args) {
    let result = false;
    if (args.length == 0)
      return false;
    for (const buttonCode of args) {
      const event = this.buttonStates.get(buttonCode);
      if (event && !event.wasReleased && !event.alreadyPressed)
        result = true;
    }
    return result;
  }
  isButtonReleased(...args) {
    let result = false;
    if (args.length == 0)
      return false;
    for (const buttonCode of args) {
      const event = this.buttonStates.get(buttonCode);
      if (event && event.wasReleased)
        result = true;
    }
    return result;
  }
  prevent(...args) {
    this._prevent.value = true;
    args.forEach((arg) => {
      this._prevent.code.push(arg);
    });
  }
  preventRemove() {
    this._prevent.value = false;
    this._prevent.code = [];
  }
  preventMiddle(button, event) {
    this._prevent.code.forEach((cd) => {
      if (this._prevent.value && button === cd) {
        event.preventDefault();
        event.stopPropagation();
      }
    });
  }
};

// src/keyboard.ts
var import_nom_events2 = __toESM(require("nom-events"));
var Keyboard = class {
  constructor() {
    this.keyDownListener = (event) => {
      if (!this.keyStates.get(event.code)) {
        this.keyStates.set(event.code, event);
        this.events.call("pressed", event.code, event);
        this.events.call("pressed_" + event.code, event.code, event);
      }
    };
    this.keyUpListener = (event) => {
      event = this.keyStates.get(event.code);
      if (event) {
        event.wasReleased = true;
        this.events.call("released", event.code, event);
        this.events.call("released_" + event.code, event.code, event);
      }
    };
    this.keyStates = /* @__PURE__ */ new Map();
    this.events = new import_nom_events2.default();
    this.set();
  }
  clear() {
    this.keyStates.clear();
  }
  update() {
    this.keyStates.forEach((value, keyCode) => {
      const event = this.keyStates.get(keyCode);
      event.alreadyPressed = true;
      if (event.wasReleased) {
        this.keyStates.delete(keyCode);
      }
      this.events.call("down", keyCode, event);
      this.events.call("down_" + keyCode, keyCode, event);
    });
  }
  isKeyDown(...args) {
    let result = false;
    for (const keyCode of args) {
      const event = this.keyStates.get(keyCode);
      if (event && !event.wasReleased)
        result = true;
    }
    return result;
  }
  isKeyUp(...args) {
    return !this.isKeyDown(args);
  }
  isKeyPressed(...args) {
    let result = false;
    if (args.length == 0)
      return false;
    for (const keyCode of args) {
      const event = this.keyStates.get(keyCode);
      if (event && !event.wasReleased && !event.alreadyPressed)
        result = true;
    }
    return result;
  }
  isKeyReleased(...args) {
    let result = false;
    if (args.length == 0)
      return false;
    for (const keyCode of args) {
      const event = this.keyStates.get(keyCode);
      if (event && event.wasReleased)
        result = true;
    }
    return result;
  }
  set() {
    window.addEventListener("keydown", this.keyDownListener, false);
    window.addEventListener("keyup", this.keyUpListener, false);
  }
  reset() {
    this.clear();
  }
};

// src/controller.ts
var PIXIController = class {
  constructor(canvas) {
    this.Canvas = canvas || document.getElementsByTagName("canvas")[0];
    this.Mouse = new Mouse(canvas || this.Canvas);
    this.Keyboard = new Keyboard();
  }
  update() {
    this.Mouse.update();
    this.Keyboard.update();
  }
  reset() {
    this.Mouse.reset();
    this.Keyboard.reset();
  }
  setContext(_canvas) {
    this.Canvas = _canvas;
    if (!this.Mouse || !this.Keyboard)
      throw new Error("Controller cannot be instantiable before the loader.");
    this.Mouse.reset(_canvas);
  }
  getContext() {
    return this.Canvas;
  }
  prevent() {
    this.Canvas.removeEventListener("contextmenu", (event) => {
      event.preventDefault();
      event.stopPropagation();
    });
    this.Canvas.addEventListener("contextmenu", (event) => {
      event.preventDefault();
      event.stopPropagation();
    });
  }
};

// src/utils.ts
var BUTTON = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2,
  FOURTH: 3,
  FIFTH: 4
};
var PLAYER = {
  UP: ["ArrowUp", "KeyW"],
  DOWN: ["ArrowDown", "KeyS"],
  LEFT: ["ArrowLeft", "KeyA"],
  RIGHT: ["ArrowRight", "KeyD"],
  INVENTORY: ["KeyI"],
  BAR: ["Digit1", "Digit2", "Digit3", "Digit4", "Digit5", "Digit6", "Digit7", "Digit8", "Digit9"]
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BUTTON,
  Keyboard,
  PIXIController,
  PLAYER
});
