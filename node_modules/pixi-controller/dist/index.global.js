"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/nom-events/Events.js
  var require_Events = __commonJS({
    "node_modules/nom-events/Events.js"(exports, module) {
      var EventElement = class {
        constructor(subEventName, isAsync, funct) {
          this.subEventName = subEventName;
          this.isAsync = isAsync;
          this.funct = funct;
        }
      };
      var Event = class {
        constructor(parent) {
          this.partent = parent;
          this.elementsMap = /* @__PURE__ */ new Map();
          this.elements = new Array();
        }
        getParent() {
          return this.parent;
        }
        condition(...args) {
          let result = true;
          this.elements.some((element) => {
            if (!element.funct(...args)) {
              result = false;
              return false;
            }
          });
          return result;
        }
        call(...args) {
          this.elements.some((element) => {
            element.funct(...args);
          });
        }
        has(subEventName) {
          return this.elementsMap.has(subEventName);
        }
        remove(subEventName) {
          if (!this.has(subEventName))
            return false;
          this.elementsMap.delete(subEventName);
          this.elements.splice(this._getIndex(subEventName), 1);
          return true;
        }
        delete(subEventName) {
          this.remove(subEventName);
        }
        clear() {
          this.elementsMap.clear();
          this.elements.length = 0;
        }
        replace(subEventName, funct) {
          if (!this.has(subEventName))
            return false;
          this.elementsMap.get(subEventName).funct = funct;
          this.elements[this._getIndex(subEventName)].funct = funct;
          return true;
        }
        prepend(subEventName, funct, isAsyncOpt) {
          let obj = new EventElement(subEventName, isAsyncOpt, funct);
          this.elementsMap.set(subEventName, obj);
          this.elements.unshift(obj);
        }
        append(subEventName, funct, isAsyncOpt) {
          let obj = new EventElement(subEventName, isAsyncOpt, funct);
          this.elementsMap.set(subEventName, obj);
          this.elements.push(obj);
        }
        insertBefore(subEventNameSeek, subEventName, funct, isAsyncOpt) {
          let index = this._getIndex(subEventNameSeek);
          let obj = new EventElement(subEventName, isAsyncOpt, funct);
          this.elementsMap.set(subEventName, obj);
          this.elements.splice(index, 0, obj);
        }
        insertAfter(subEventNameSeek, subEventName, funct, isAsyncOpt) {
          let index = this._getIndex(subEventNameSeek);
          let obj = new EventElement(subEventName, isAsyncOpt, funct);
          this.elementsMap.set(subEventName, obj);
          this.elements.splice(index + 1, 0, obj);
        }
        _getIndex(subEventNameSeek) {
          return this.elements.findIndex((element) => element.subEventName == subEventNameSeek);
        }
      };
      var Events3 = class {
        constructor() {
          this.elementsMap = /* @__PURE__ */ new Map();
        }
        condition(eventName, ...args) {
          return new Promise((resolve, reject) => {
            let element = this.elementsMap.get(eventName);
            if (element)
              resolve(element.condition());
            resolve(true);
          });
        }
        emit(...args) {
          this.call(...args);
        }
        call(eventName, ...args) {
          return new Promise((resolve, reject) => {
            let element;
            element = this.elementsMap.get("pre_" + eventName);
            if (element)
              element.call(...args);
            element = this.elementsMap.get(eventName);
            if (element)
              element.call(...args);
            element = this.elementsMap.get("post_" + eventName);
            if (element)
              element.call(...args);
            resolve();
          });
        }
        has(eventName, subEventName) {
          if (!this.elementsMap.has(eventName))
            return false;
          if (!subEventName)
            return true;
          return this.elementsMap.get(eventName).has(subEventName);
        }
        remove(eventName, subEventName) {
          if (!this.has(eventName))
            return false;
          if (!subEventName) {
            this.elementsMap.delete(eventName);
            return true;
          }
          return this.elementsMap.get(eventName).remove(subEventName);
        }
        delete(eventName, subEventName) {
          this.remove(eventName, subEventName);
        }
        clear(eventName) {
          if (!eventName) {
            this.elementsMap.clear();
            return;
          }
          this.elementsMap.get(eventName).clear();
        }
        prepend(eventName, subEventName, funct, isAsyncOpt) {
          this._attainEvent(eventName).prepend(subEventName, funct, isAsyncOpt);
        }
        on(...args) {
          this.append(...args);
        }
        append(eventName, subEventName, funct, isAsyncOpt) {
          if (typeof subEventName === "function") {
            let values = Object.values(arguments);
            values.splice(1, 0, "_");
            this.append(...values);
            return;
          }
          this._attainEvent(eventName).append(subEventName, funct, isAsyncOpt);
        }
        insertBefore(eventName, subEventName, subEventNameSeek, funct, isAsyncOpt) {
          if (typeof subEventNameSeek === "function") {
            let values = Object.values(arguments);
            values.splice(1, 0, "_");
            this.insertBefore(...values);
            return;
          }
          this._attainEvent(eventName).insertBefore(subEventName, subEventNameSeek, funct, isAsyncOpt);
        }
        insertAfter(eventName, subEventName, subEventNameSeek, funct, isAsyncOpt) {
          if (typeof subEventNameSeek === "function") {
            let values = Object.values(arguments);
            values.splice(1, 0, "_");
            this.insertAfter(...values);
            return;
          }
          this._attainEvent(eventName).insertAfter(subEventName, subEventNameSeek, funct, isAsyncOpt);
        }
        _attainEvent(eventName) {
          if (!this.elementsMap.has(eventName))
            this.elementsMap.set(eventName, new Event(this));
          return this.elementsMap.get(eventName);
        }
      };
      module.exports = Events3;
    }
  });

  // node_modules/nom-events/index.js
  var require_nom_events = __commonJS({
    "node_modules/nom-events/index.js"(exports, module) {
      var Events3 = require_Events();
      module.exports = Events3;
    }
  });

  // src/mouse.ts
  var import_nom_events = __toESM(require_nom_events());
  var Mouse = class {
    constructor(canvas) {
      this.posLocalY = 0;
      this.posLocalX = 0;
      this.posGlobalX = 0;
      this.posGlobalY = 0;
      this._prevent = {
        value: false,
        code: []
      };
      this.mouseMoveListener = (event) => {
        const buttonCode = event.button;
        this.preventMiddle(buttonCode, event);
        if (this.posLocalX != event.clientX || this.posLocalY != event.clientY) {
          this.events.call("move", event.clientX, this.posLocalY);
          this.events.call("moveLocal", event.clientX, this.posLocalY);
          this.posLocalX = event.clientX;
          this.posLocalY = event.clientY;
        }
        if (this.posGlobalX != event.screenX || this.posGlobalY != event.screenY) {
          this.events.call("moveGlobal", event.screenX, event.screenY);
          this.posGlobalX = event.screenX;
          this.posGlobalY = event.screenY;
        }
      };
      this.mouseDownListener = (event) => {
        const buttonCode = event.button;
        this.preventMiddle(buttonCode, event);
        if (!this.buttonStates.get(buttonCode)) {
          event.posLocalX = this.getPosLocalX();
          event.posLocalY = this.getPosLocalY();
          this.buttonStates.set(buttonCode, event);
          this.events.call("pressed", buttonCode, event, this.getPosLocalX(), this.getPosLocalY());
          this.events.call("pressed_" + buttonCode, buttonCode, event, this.getPosLocalX(), this.getPosLocalY());
        }
      };
      this.mouseUpListener = (event) => {
        const buttonCode = event.button;
        this.preventMiddle(buttonCode, event);
        event = this.buttonStates.get(buttonCode);
        if (event) {
          event.wasReleased = true;
          this.events.call(
            "released",
            buttonCode,
            event,
            this.getPosLocalX(),
            this.getPosLocalY(),
            event.posLocalX,
            event.posLocalY,
            this.getPosLocalX() - event.posLocalX,
            this.getPosLocalY() - event.posLocalY
          );
          this.events.call(
            "released_" + buttonCode,
            buttonCode,
            event,
            this.getPosLocalX(),
            this.getPosLocalY(),
            event.posLocalX,
            event.posLocalY,
            this.getPosLocalX() - event.posLocalX,
            this.getPosLocalY() - event.posLocalY
          );
        }
      };
      this.mouseMenuContext = (event) => {
        this.preventMiddle(event.button, event);
      };
      this.buttonStates = /* @__PURE__ */ new Map();
      this.events = new import_nom_events.default();
      this.canvasElement = canvas;
      if (!this.canvasElement)
        throw new Error("pixi-controller: error for search <canvas /> tag.");
      this.canvasElement.addEventListener("mousemove", this.mouseMoveListener);
      this.canvasElement.addEventListener("mousedown", this.mouseDownListener);
      this.canvasElement.addEventListener("mouseup", this.mouseUpListener);
      this.canvasElement.addEventListener("contextmenu", this.mouseMenuContext);
    }
    getMousePos(event) {
      const rect = this.canvasElement.getBoundingClientRect();
      return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
      };
    }
    getPosGlobalX() {
      return this.posGlobalX;
    }
    getPosGlobalY() {
      return this.posGlobalY;
    }
    getPosLocalX() {
      return this.posLocalX;
    }
    getPosLocalY() {
      return this.posLocalY;
    }
    getPosX() {
      return this.getPosLocalX();
    }
    getPosY() {
      return this.getPosLocalY();
    }
    clear() {
      this.buttonStates.clear();
    }
    reset(_canvas) {
      _canvas ? this.canvasElement = _canvas : this.canvasElement = document.getElementsByTagName("canvas")[0];
      this.clear();
      this.events = new import_nom_events.default();
      this.canvasElement.removeEventListener("mousemove", this.mouseMoveListener);
      this.canvasElement.removeEventListener("mousedown", this.mouseDownListener);
      this.canvasElement.removeEventListener("mouseup", this.mouseUpListener);
      this.canvasElement.removeEventListener("contextmenu", this.mouseMenuContext);
      this.canvasElement.addEventListener("mousemove", this.mouseMoveListener);
      this.canvasElement.addEventListener("mousedown", this.mouseDownListener);
      this.canvasElement.addEventListener("mouseup", this.mouseUpListener);
      this.canvasElement.addEventListener("contextmenu", this.mouseMenuContext);
    }
    update() {
      this.buttonStates.forEach((value, buttonCode) => {
        const event = this.buttonStates.get(buttonCode);
        event.alreadyPressed = true;
        if (event.wasReleased)
          this.buttonStates.delete(buttonCode);
        this.events.call(
          "down",
          buttonCode,
          event,
          this.getPosLocalX(),
          this.getPosLocalY(),
          event.posLocalX,
          event.posLocalY,
          this.getPosLocalX() - event.posLocalX,
          this.getPosLocalY() - event.posLocalY
        );
        this.events.call(
          "down_" + buttonCode,
          buttonCode,
          event,
          this.getPosLocalX(),
          this.getPosLocalY(),
          event.posLocalX,
          event.posLocalY,
          this.getPosLocalX() - event.posLocalX,
          this.getPosLocalY() - event.posLocalY
        );
      });
    }
    isButtonDown(...args) {
      let result = false;
      for (const buttonCode of args) {
        const key = this.buttonStates.get(buttonCode);
        if (key && !key.wasReleased)
          result = true;
      }
      return result;
    }
    isButtonUp(...args) {
      return !this.isButtonDown(args);
    }
    isButtonPressed(...args) {
      let result = false;
      if (args.length == 0)
        return false;
      for (const buttonCode of args) {
        const event = this.buttonStates.get(buttonCode);
        if (event && !event.wasReleased && !event.alreadyPressed)
          result = true;
      }
      return result;
    }
    isButtonReleased(...args) {
      let result = false;
      if (args.length == 0)
        return false;
      for (const buttonCode of args) {
        const event = this.buttonStates.get(buttonCode);
        if (event && event.wasReleased)
          result = true;
      }
      return result;
    }
    prevent(...args) {
      this._prevent.value = true;
      args.forEach((arg) => {
        this._prevent.code.push(arg);
      });
    }
    preventRemove() {
      this._prevent.value = false;
      this._prevent.code = [];
    }
    preventMiddle(button, event) {
      this._prevent.code.forEach((cd) => {
        if (this._prevent.value && button === cd) {
          event.preventDefault();
          event.stopPropagation();
        }
      });
    }
  };

  // src/keyboard.ts
  var import_nom_events2 = __toESM(require_nom_events());
  var Keyboard = class {
    constructor() {
      this.keyDownListener = (event) => {
        if (!this.keyStates.get(event.code)) {
          this.keyStates.set(event.code, event);
          this.events.call("pressed", event.code, event);
          this.events.call("pressed_" + event.code, event.code, event);
        }
      };
      this.keyUpListener = (event) => {
        event = this.keyStates.get(event.code);
        if (event) {
          event.wasReleased = true;
          this.events.call("released", event.code, event);
          this.events.call("released_" + event.code, event.code, event);
        }
      };
      this.keyStates = /* @__PURE__ */ new Map();
      this.events = new import_nom_events2.default();
      this.set();
    }
    clear() {
      this.keyStates.clear();
    }
    update() {
      this.keyStates.forEach((value, keyCode) => {
        const event = this.keyStates.get(keyCode);
        event.alreadyPressed = true;
        if (event.wasReleased) {
          this.keyStates.delete(keyCode);
        }
        this.events.call("down", keyCode, event);
        this.events.call("down_" + keyCode, keyCode, event);
      });
    }
    isKeyDown(...args) {
      let result = false;
      for (const keyCode of args) {
        const event = this.keyStates.get(keyCode);
        if (event && !event.wasReleased)
          result = true;
      }
      return result;
    }
    isKeyUp(...args) {
      return !this.isKeyDown(args);
    }
    isKeyPressed(...args) {
      let result = false;
      if (args.length == 0)
        return false;
      for (const keyCode of args) {
        const event = this.keyStates.get(keyCode);
        if (event && !event.wasReleased && !event.alreadyPressed)
          result = true;
      }
      return result;
    }
    isKeyReleased(...args) {
      let result = false;
      if (args.length == 0)
        return false;
      for (const keyCode of args) {
        const event = this.keyStates.get(keyCode);
        if (event && event.wasReleased)
          result = true;
      }
      return result;
    }
    set() {
      window.addEventListener("keydown", this.keyDownListener, false);
      window.addEventListener("keyup", this.keyUpListener, false);
    }
    reset() {
      this.clear();
    }
  };

  // src/controller.ts
  var PIXIController = class {
    constructor(canvas) {
      this.Canvas = canvas || document.getElementsByTagName("canvas")[0];
      this.Mouse = new Mouse(canvas || this.Canvas);
      this.Keyboard = new Keyboard();
    }
    update() {
      this.Mouse.update();
      this.Keyboard.update();
    }
    reset() {
      this.Mouse.reset();
      this.Keyboard.reset();
    }
    setContext(_canvas) {
      this.Canvas = _canvas;
      if (!this.Mouse || !this.Keyboard)
        throw new Error("Controller cannot be instantiable before the loader.");
      this.Mouse.reset(_canvas);
    }
    getContext() {
      return this.Canvas;
    }
    prevent() {
      this.Canvas.removeEventListener("contextmenu", (event) => {
        event.preventDefault();
        event.stopPropagation();
      });
      this.Canvas.addEventListener("contextmenu", (event) => {
        event.preventDefault();
        event.stopPropagation();
      });
    }
  };

  // src/utils.ts
  var BUTTON = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    FOURTH: 3,
    FIFTH: 4
  };
  var PLAYER = {
    UP: ["ArrowUp", "KeyW"],
    DOWN: ["ArrowDown", "KeyS"],
    LEFT: ["ArrowLeft", "KeyA"],
    RIGHT: ["ArrowRight", "KeyD"],
    INVENTORY: ["KeyI"],
    BAR: ["Digit1", "Digit2", "Digit3", "Digit4", "Digit5", "Digit6", "Digit7", "Digit8", "Digit9"]
  };
})();
